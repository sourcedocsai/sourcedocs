import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { getUserByGithubId, getUserGithubToken } from '@/lib/db';

/**
 * Document type to filename mapping
 * Determines where each document type gets saved in the repository
 */
const DOC_TYPE_FILES: Record<string, string> = {
  readme: 'README.md',
  changelog: 'CHANGELOG.md',
  contributing: 'CONTRIBUTING.md',
  license: 'LICENSE',
  codeofconduct: 'CODE_OF_CONDUCT.md',
  classdiagram: 'docs/CLASS_DIAGRAM.md',
};

/**
 * Documentation style labels for each file extension
 * Used in PR descriptions for code comments
 */
const DOC_STYLE_BY_EXT: Record<string, string> = {
  js: 'JSDoc',
  jsx: 'JSDoc',
  ts: 'TSDoc',
  tsx: 'TSDoc',
  py: 'Google-style docstrings',
  go: 'GoDoc',
  rs: 'rustdoc',
  java: 'Javadoc',
  kt: 'KDoc',
  rb: 'YARD',
  php: 'PHPDoc',
  swift: 'Swift documentation',
  cs: 'XML documentation',
  c: 'Doxygen',
  cpp: 'Doxygen',
  h: 'Doxygen',
};

/**
 * GitHub API error response shape
 */
interface GitHubApiError {
  message: string;
  documentation_url?: string;
}

/**
 * Get the documentation style name based on file extension
 * Used for code comments PR descriptions
 */
function getDocStyleForFile(filename: string): string {
  const ext = filename.split('.').pop()?.toLowerCase() || '';
  return DOC_STYLE_BY_EXT[ext] || 'language-native documentation';
}

/**
 * Generate a detailed PR description based on the document type
 * Each type gets a customized description explaining what was added/changed
 */
function generatePRDescription(
  docType: string,
  filename: string,
  isUpdate: boolean
): string {
  // Special description for class diagrams
  if (docType === 'classdiagram') {
    return `## ${isUpdate ? 'Updated' : 'Added'} Class Diagram

This pull request ${isUpdate ? 'updates' : 'adds'} a visual class diagram showing the object-oriented structure of the codebase.

### What's Included

The diagram shows classes, interfaces, and their relationships including inheritance, composition, and associations. It was generated by analyzing the source code structure.

### How to View

The diagram uses Mermaid syntax, which GitHub renders automatically. Simply view the file on GitHub to see the visual diagram.

### Keeping Documentation Current

Class diagrams can become outdated as code evolves. Consider regenerating this diagram periodically using [SourceDocs.ai](https://www.sourcedocs.ai) to ensure it reflects the current codebase structure.

---

<sub>Generated by [SourceDocs.ai](https://www.sourcedocs.ai) - AI-powered documentation for developers</sub>
`;
  }

  // Special description for code comments
  if (docType === 'comments') {
    const docStyle = getDocStyleForFile(filename);
    return `## Added Documentation Comments

This pull request adds comprehensive documentation comments to \`${filename}\`.

### What's Changed

The file now includes ${docStyle} documentation covering function descriptions, parameter documentation, return value documentation, and usage notes where appropriate.

### Documentation Style

Comments follow **${docStyle}** conventions, which is the standard documentation format for this language.

### About SourceDocs

[SourceDocs.ai](https://www.sourcedocs.ai) uses AI to analyze code and generate professional documentation comments in the native format for your language. It supports JavaScript, TypeScript, Python, Go, Rust, Java, and many more.

---

<sub>Generated by [SourceDocs.ai](https://www.sourcedocs.ai) - AI-powered documentation for developers</sub>
`;
  }

  // Standard document types (README, CHANGELOG, etc.)
  const action = isUpdate ? 'Updated' : 'Added';
  const docTypeLabels: Record<string, string> = {
    readme: 'README',
    changelog: 'CHANGELOG',
    contributing: 'Contributing Guidelines',
    license: 'License',
    codeofconduct: 'Code of Conduct',
  };

  const label = docTypeLabels[docType] || docType.toUpperCase();

  return `## ${action} ${label}

This pull request was automatically generated by [SourceDocs.ai](https://www.sourcedocs.ai).

### What's Changed

${isUpdate ? `The \`${filename}\` file has been updated with improved documentation.` : `A new \`${filename}\` file has been added to the repository.`}

### About SourceDocs

[SourceDocs.ai](https://www.sourcedocs.ai) uses AI to analyze your codebase and generate professional documentation. It supports README files, changelogs, contributing guidelines, license files, code of conduct documents, code comments, and class diagrams.

---

<sub>Generated by [SourceDocs.ai](https://www.sourcedocs.ai) - AI-powered documentation for developers</sub>
`;
}

/**
 * Wrap content appropriately based on document type
 * Class diagrams get wrapped in markdown with the Mermaid code fence
 */
function wrapContent(content: string, docType: string): string {
  if (docType === 'classdiagram') {
    return `# Class Diagram

This diagram shows the class structure and relationships in the codebase.

\`\`\`mermaid
${content}
\`\`\`

---

*Generated by [SourceDocs.ai](https://www.sourcedocs.ai)*
`;
  }
  
  return content;
}

/**
 * POST /api/pr
 * 
 * Create a Pull Request with generated documentation content.
 * Supports all document types including README, code comments, and class diagrams.
 * 
 * Request body:
 * - owner: Repository owner (required)
 * - repo: Repository name (required)
 * - content: Generated content to commit (required)
 * - docType: Type of document (required)
 * - filePath: Target file path (required for comments, optional for others)
 * - baseBranch: Branch to merge into (optional, defaults to repo default)
 */
export async function POST(request: NextRequest) {
  try {
    // Authenticate user
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: 'Authentication required' }, { status: 401 });
    }

    const githubId = (session.user as any).githubId;
    const user = await getUserByGithubId(githubId);

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Get the stored GitHub access token for API calls
    const accessToken = await getUserGithubToken(user.id);
    if (!accessToken) {
      return NextResponse.json(
        {
          error: 'GitHub authorization required',
          requiresReauth: true,
          message: 'Please sign out and sign back in to grant repository access permissions.',
        },
        { status: 403 }
      );
    }

    // Parse and validate request body
    const body = await request.json();
    const { owner, repo, content, docType, filePath, baseBranch } = body;

    // Validate owner and repo: must be valid GitHub login/repo names
    const validName = /^[A-Za-z0-9_.-]+$/;
    if (
      !owner || !repo || !content || !docType ||
      !validName.test(owner) || !validName.test(repo)
    ) {
      return NextResponse.json(
        { error: 'Missing or invalid required fields: owner, repo, content, docType' },
        { status: 400 }
      );
    }

    // Validate baseBranch, if provided: must match valid branch name pattern
    // (GitHub branch names are more permissive, but we'll limit to safe subset)
    if (baseBranch && !/^[A-Za-z0-9/_\-.]+$/.test(baseBranch)) {
      return NextResponse.json(
        { error: 'Invalid baseBranch format' },
        { status: 400 }
      );
    }

    // Determine the target filename based on document type
    let filename: string;
    if (docType === 'comments') {
      // For code comments, filePath is required and contains the full path
      if (!filePath) {
        return NextResponse.json(
          { error: 'filePath is required for code comments' },
          { status: 400 }
        );
      }
      filename = filePath;
    } else {
      // For standard docs and class diagrams, use the predefined filename
      filename = DOC_TYPE_FILES[docType];
      if (!filename) {
        return NextResponse.json({ error: 'Invalid document type' }, { status: 400 });
      }
    }

    // GitHub API headers
    const headers = {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/vnd.github.v3+json',
      'User-Agent': 'SourceDocs',
    };

    // Step 1: Get repository info including default branch
    const repoResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}`,
      { headers }
    );

    if (!repoResponse.ok) {
      const error = (await repoResponse.json()) as GitHubApiError;
      if (repoResponse.status === 404) {
        return NextResponse.json(
          { error: 'Repository not found or you do not have access' },
          { status: 404 }
        );
      }
      return NextResponse.json(
        { error: `GitHub API error: ${error.message}` },
        { status: repoResponse.status }
      );
    }

    const repoData = (await repoResponse.json()) as { default_branch: string };
    // Use provided baseBranch (for comments) or fall back to repo default
    const targetBranch = baseBranch || repoData.default_branch;

    // Step 2: Get the latest commit SHA from the target branch
    const refResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/git/ref/heads/${targetBranch}`,
      { headers }
    );

    if (!refResponse.ok) {
      const error = (await refResponse.json()) as GitHubApiError;
      return NextResponse.json(
        { error: `Failed to get branch reference: ${error.message}` },
        { status: refResponse.status }
      );
    }

    const refData = (await refResponse.json()) as { object: { sha: string } };
    const baseSha = refData.object.sha;

    // Step 3: Create a descriptive branch name
    const sanitizedFilename = filename.split('/').pop()?.replace(/[^a-zA-Z0-9.-]/g, '-') || 'file';
    const timestamp = Date.now();
    
    let branchName: string;
    if (docType === 'comments') {
      branchName = `sourcedocs/document-${sanitizedFilename}-${timestamp}`;
    } else if (docType === 'classdiagram') {
      branchName = `sourcedocs/add-class-diagram-${timestamp}`;
    } else {
      branchName = `sourcedocs/update-${docType}-${timestamp}`;
    }

    // Step 4: Create the new branch
    const createBranchResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/git/refs`,
      {
        method: 'POST',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ref: `refs/heads/${branchName}`,
          sha: baseSha,
        }),
      }
    );

    if (!createBranchResponse.ok) {
      const error = (await createBranchResponse.json()) as GitHubApiError;
      return NextResponse.json(
        { error: `Failed to create branch: ${error.message}` },
        { status: createBranchResponse.status }
      );
    }

    // Step 5: Check if the file already exists (to get its SHA for updates)
    let existingFileSha: string | undefined;
    const fileCheckResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${filename}?ref=${branchName}`,
      { headers }
    );

    if (fileCheckResponse.ok) {
      const fileData = (await fileCheckResponse.json()) as { sha: string };
      existingFileSha = fileData.sha;
    }

    // Step 6: Prepare and commit the file content
    const wrappedContent = wrapContent(content, docType);
    
    const commitMessage =
      docType === 'comments'
        ? `docs: add documentation comments to ${filename}`
        : docType === 'classdiagram'
          ? `docs: ${existingFileSha ? 'update' : 'add'} class diagram`
          : existingFileSha
            ? `docs: update ${filename} via SourceDocs.ai`
            : `docs: add ${filename} via SourceDocs.ai`;

    const createFileResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${filename}`,
      {
        method: 'PUT',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: commitMessage,
          content: Buffer.from(wrappedContent).toString('base64'),
          branch: branchName,
          ...(existingFileSha && { sha: existingFileSha }),
        }),
      }
    );

    if (!createFileResponse.ok) {
      const error = (await createFileResponse.json()) as GitHubApiError;
      return NextResponse.json(
        { error: `Failed to create file: ${error.message}` },
        { status: createFileResponse.status }
      );
    }

    // Step 7: Create the Pull Request
    const prTitle =
      docType === 'comments'
        ? `docs: Add documentation comments to ${filename.split('/').pop()}`
        : docType === 'classdiagram'
          ? `docs: ${existingFileSha ? 'Update' : 'Add'} class diagram`
          : existingFileSha
            ? `docs: Update ${filename}`
            : `docs: Add ${filename}`;

    const prBody = generatePRDescription(docType, filename, existingFileSha !== undefined);

    const createPRResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: 'POST',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: prTitle,
          body: prBody,
          head: branchName,
          base: targetBranch,
        }),
      }
    );

    if (!createPRResponse.ok) {
      const error = (await createPRResponse.json()) as GitHubApiError;
      return NextResponse.json(
        { error: `Failed to create pull request: ${error.message}` },
        { status: createPRResponse.status }
      );
    }

    const prData = (await createPRResponse.json()) as {
      html_url: string;
      number: number;
      title: string;
    };

    // Return success with PR details
    return NextResponse.json({
      success: true,
      pr: {
        url: prData.html_url,
        number: prData.number,
        title: prData.title,
        branch: branchName,
        baseBranch: targetBranch,
        file: filename,
      },
    });

  } catch (error) {
    console.error('PR creation error:', error);
    return NextResponse.json({ error: 'Failed to create pull request' }, { status: 500 });
  }
}
